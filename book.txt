.
./update.sh
./book.txt
./discretization.cpp
int get_index(int a)
{
	return lower_bound(discrete, discrete + discrete_num, a) - discrete;
}

void discretization(int discrete[], int &discrete_num)
{
	sort(discrete, discrete + discrete_num);
	discrete_num = unique(discrete, discrete + discrete_num) - discrete;
}
./clean.sh
./grid move
./grid move/grid_move.cpp
struct Point
{
	int x, y;
	Point()
	{}
	Point(int x, int y):x(x), y(y)
	{}
	Point operator + (const Point &a)
	{
		return Point(x + a.x, y + a.y);
	}
};

Point dir[4] = {Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)};
bool vis[MAX_X][MAX_Y];
int row_num, col_num;
char dir_name[] = "DRUL";
int grid[MAX_X][MAX_Y];

void visit(Point a)
{
	vis[a.x][a.y] = true;
}

bool out(Point a)
{
	return a.x < 0 || a.y < 0 || a.x >= row_num || a.y >= col_num;
}

bool visited(Point a)
{
	return vis[a.x][a.y];
}
./grid move/grid_move_bfs_pq.cpp
struct Point
{
	int x, y;
	int time;
	Point()
	{}
	Point(int x, int y):x(x), y(y)
	{}
	Point(int x, int y, int t): x(x), y(y), time(t)
	{}
	Point operator + (const Point &a)
	{
		return Point(x + a.x, y + a.y);
	}
	bool operator < (const Point &a) const
	{
		return time > a.time;
	}
	bool operator == (const Point &a) const
	{
		return x == a.x && y == a.y;
	}
};

Point dir[4] = {Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)};
bool vis[MAX_X][MAX_Y];
int dis[MAX_X][MAX_Y];
int row_num, col_num;
char dir_name[] = "DRUL";
char dir_name2[] = "SENW";
char grid[MAX_X][MAX_Y];
Point start, end;

void visit(Point a)
{
	vis[a.x][a.y] = true;
}

bool out(Point a)
{
	return a.x < 0 || a.y < 0 || a.x >= row_num || a.y >= col_num;
}

bool visited(Point a)
{
	return vis[a.x][a.y];
}

void input()
{
	scanf("%d", &row_num);
	col_num = row_num;
	for (int i = 0; i < row_num; i++)
	{
		scanf("%s", grid[i]);
	}
	for (int i = 0; i < row_num; i++)
	{
		for (int j = 0; j < col_num; j++)
		{
			if (grid[i][j] == 'M')
			{
				start = Point(i, j);
				grid[i][j] = '.';
			}
			if (grid[i][j] == 'T')
			{
				end = Point(i, j);
				grid[i][j] = '.';
			}
		}
	}
}

void init()
{
	for (int i = 0; i < row_num; i++)
	{
		for (int j = 0; j < col_num; j++)
		{
			vis[i][j] = false;
			dis[i][j] = INF;
		}
	}
}

int bfs()
{
	init();
	priority_queue<Point> pq;
	start.time = 0;
	pq.push(start);
	while (!pq.empty())
	{
		Point u = pq.top();
		pq.pop();
		if (u == end)
		{
			return u.time;
		}
		if (visited(u))
		{
			continue;
		}
		visit(u);
		for (int i = 0; i < 4; i++)
		{
			Point v = u + dir[i];
			if (out(v) || grid[v.x][v.y] != '.')
			{
				continue;
			}
			if (u.time + 1 < dis[v.x][v.y])
			{
				dis[v.x][v.y] = u.time + 1;
				pq.push(Point(v.x, v.y, u.time + 1));
			}
		}
	}
	return -1;
}

./DFA
./DFA/ac_automation.cpp
//1.init() 2.insert() 3.build() 4.query()
struct Trie
{
	int next[MAX_NODE_NUM][MAX_CHILD_NUM];
	int fail[MAX_NODE_NUM];
	int count[MAX_NODE_NUM];
	int node_cnt;
	bool vis[MAX_NODE_NUM]; //set it to false
	int root;

	void init()
	{
		node_cnt = 0;
		root = newnode();
		memset(vis, 0, sizeof(vis));
	}

	int newnode()
	{
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			next[node_cnt][i] = -1;
		count[node_cnt++] = 0;
		return node_cnt - 1;
	}

	int get_id(char a)
	{
		return a - 'A';
	}

	void insert(char buf[])
	{
		int now = root;
		for (int i = 0; buf[i]; i++)
		{
			int id = get_id(buf[i]);
			if (next[now][id] == -1)
				next[now][id] = newnode();
			now = next[now][id];
		}
		count[now]++;
	}

	void build()
	{
		queue<int>Q;
		fail[root] = root;
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			if (next[root][i] == -1)
				next[root][i] = root;
			else
			{
				fail[next[root][i]] = root;
				Q.push(next[root][i]);
			}
		while (!Q.empty())
		{
			int now = Q.front();
			Q.pop();
			for (int i = 0; i < MAX_CHILD_NUM; i++)
				if (next[now][i] == -1)
					next[now][i] = next[fail[now]][i];
				else
				{
					fail[next[now][i]]=next[fail[now]][i];
					Q.push(next[now][i]);
				}
		}
	}

	int query(char buf[])
	{
		int now = root;
		int res = 0;

		memset(vis, 0, sizeof(vis));
		for (int i = 0; buf[i]; i++)
		{
			now = next[now][get_id(buf[i])];
			int temp = now;
			while (temp != root && !vis[temp])
			{
				res += count[temp];
 				// optimization: prevent from searching this fail chain again.
				//also prevent matching again.
				vis[temp] = true;
				temp = fail[temp];
			}
		}
		return res;
	}

	void debug()
	{
		for(int i = 0;i < node_cnt;i++)
		{
			printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],count[i]);
			for(int j = 0;j < MAX_CHILD_NUM;j++)
				printf("%2d",next[i][j]);
			printf("]\n");
		}
	}
};


./DFA/ac_automation_matrix.cpp
struct Trie
{
	int next[MAX_NODE_NUM][MAX_CHILD_NUM];
	int fail[MAX_NODE_NUM];
	int count[MAX_NODE_NUM];
	int node_cnt;
	bool vis[MAX_NODE_NUM]; //set it to false
	int root;

	void init()
	{
		node_cnt = 0;
		root = newnode();
		memset(vis, 0, sizeof(vis));
	}

	int newnode()
	{
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			next[node_cnt][i] = -1;
		count[node_cnt++] = 0;
		return node_cnt - 1;
	}

	int get_id(char a)
	{
		return a - 'A';
	}

	void insert(char buf[])
	{
		int now = root;
		for (int i = 0; buf[i]; i++)
		{
			int id = get_id(buf[i]);
			if (next[now][id] == -1)
				next[now][id] = newnode();
			now = next[now][id];
		}
		count[now]++;
	}

	void build()
	{
		queue<int>Q;
		fail[root] = root;
		for (int i = 0; i < MAX_CHILD_NUM; i++)
			if (next[root][i] == -1)
				next[root][i] = root;
			else
			{
				fail[next[root][i]] = root;
				Q.push(next[root][i]);
			}
		while (!Q.empty())
		{
			int now = Q.front();
			Q.pop();
			for (int i = 0; i < MAX_CHILD_NUM; i++)
				if (next[now][i] == -1)
					next[now][i] = next[fail[now]][i];
				else
				{
					fail[next[now][i]]=next[fail[now]][i];
					Q.push(next[now][i]);
				}
		}
	}

	int query(char buf[])
	{
		int now = root;
		int res = 0;

		memset(vis, 0, sizeof(vis));
		for (int i = 0; buf[i]; i++)
		{
			now = next[now][get_id(buf[i])];
			int temp = now;
			while (temp != root && !vis[temp])
			{
				res += count[temp];
 				// optimization: prevent from searching this fail chain again.
				//also prevent matching again.
				vis[temp] = true;
				temp = fail[temp];
			}
		}
		return res;
	}

	void debug()
	{
		for(int i = 0;i < node_cnt;i++)
		{
			printf("id = %3d,fail = %3d,end = %3d,chi = [",i,fail[i],count[i]);
			for(int j = 0;j < MAX_CHILD_NUM;j++)
				printf("%2d",next[i][j]);
			printf("]\n");
		}
	}
}ac;

struct Matrix
{
	int order;
	int num[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];

	Matrix()
	{}

	Matrix(int ord)
	{
		order = ord;
	}

	void init()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				num[i][j] = 0;
			}
		}
	}
	void output()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				printf("%d ", num[i][j]);
			}
			puts("");
		}
	}
};

Matrix operator*(Matrix ma, Matrix mb)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	int i, j, k;
	for (i = 0; i < ord; i++)
	{
		for (k = 0; k < ord; k++)
		{
			if (ma.num[i][k] == 0)
				continue;
			for (j = 0; j < ord; j++)
			{
				long long temp = ma.num[i][k] * (long long)mb.num[k][j];
				temp %= MOD;
				numc.num[i][j] += temp;
				numc.num[i][j] %= MOD;
			}
		}
	}
	return numc;
}

Matrix matrix_power(Matrix ma, int x)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	for (int i = 0; i < ord; i++)
	{
		numc.num[i][i] = 1;
	}
	for (; x; x >>= 1)
	{
		if (x & 1)
		{
			numc = numc * ma;
		}
		ma = ma * ma;
	}
	return numc;
}

void extract_matrix(Matrix &matrix)
{
	matrix.order = ac.node_cnt;
	matrix.init();
	for (int i = 0; i < ac.node_cnt; i++)
	{
		for (int j = 0; j < MAX_CHILD_NUM; j++)
		{
			if (ac.next[i][j] == NULL)
				continue;
			int temp = ac.next[i][j];
			if (ac.count[temp] == 0)
			{
				matrix.num[i][temp] += 1;
			}
		}
	}
}

./RMQ&LCA
./RMQ&LCA/LCA_online_bfs.cpp
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define MAX_Q_LEN MAX_NODE_NUM
#define M 30

struct Edge
{
	int v, next, id;
	Edge()
	{}
	Edge(int v, int next, int id):v(v), next(next), id(id)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int id)
{
	edge[edge_cnt] = Edge(v, head[u], id);
	head[u] = edge_cnt++;
}

bool vis[MAX_NODE_NUM];
int father[MAX_NODE_NUM][M];
int depth[MAX_NODE_NUM];

template<typename T>
class queue
{
	T data[MAX_Q_LEN];
	int head, tail;

public:
	queue()
	{
		head = tail = 0;
	}

	bool empty()
	{
		return head == tail;
	}

	void pop()
	{
		head++;
		if (head >= MAX_Q_LEN)
			head = 0;
	}

	void push(T a)
	{
		data[tail++] = a;
		if (tail >= MAX_Q_LEN)
			tail = 0;
	}

	T front()
	{
		return data[head];
	}
};

void bfs(int root)
{
	queue<int> q;
	q.push(root);
	seq2_cnt = 0;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = true;
		seq2[seq2_cnt++] = u;
		for (int i = head[u]; i != -1; i = edge[i].next)
		{
			int v = edge[i].v;
			if (vis[v])
			{
				continue;
			}
			father[v][0] = u;
			depth[v] = depth[u] + 1;
			q.push(v);
		}
	}
}

//index start from 1.
void init_LCA(int root)
{
	fill_n(vis, node_num + 1, 0);
	memset(father, 0, sizeof(father));
	bfs(root);
	bool did;
	for (int i = 1; i < M; i++)
	{
		did = false;
		for (int j = 1; j <= node_num; j++)
		{
			int k = father[j][i - 1];
			if (k <= 0)
			{
				continue;
			}
			father[j][i] = father[k][i - 1];
			did = true;
		}
		if (!did)
		{
			break;
		}
	}
}

//O(log(n))
int LCA(int x, int y)
{
	if (depth[x] > depth[y])
	{
		swap(x, y);
	}
	int diff = depth[y] - depth[x];
	for (int i = 0; i < M && diff; i++)
	{
		if (diff & 1)
		{
			y = father[y][i];
		}
		diff >>= 1;
	}
	if (x == y)
	{
		return x;
	}
	int exp = 0;
	while (x != y)
	{
		if (!exp || father[x][exp] != father[y][exp])
		{
			x = father[x][exp];
			y = father[y][exp];
			exp++;
		}else
		{
			exp--;
		}
	}
	return x;
}


./RMQ&LCA/RMQ_ST.cpp
//call init_RMQ(f[], n) first.
//then call query(a, b) to quest the RMQ of [a, b].
int power[30];
int st[MAX_NODE_NUM * 2][32];
int ln[MAX_NODE_NUM * 2];

//returns the index of the first minimum value in [x, y]
void init_RMQ(int f[], int n)
{
	int i, j;
	for (power[0] = 1, i = 1; i < 21; i++)
	{
		power[i] = 2 * power[i - 1];
	}
	for (i = 0; i < n; i++)
	{
		st[i][0] = i;
	}
	ln[0] = -1;
	for (int i = 1; i <= n; i++)
	{
		ln[i] = ln[i >> 1] + 1;
	}
	for (j = 1; j < ln[n]; j++)
	{
		for (i = 0; i < n; i++)
		{
			if (i + power[j - 1] - 1 >= n)
			{
				break;
			}
			//for maximum, change ">" to "<"
			//for the last, change "<" or ">" to "<=" or ">="
			if (f[st[i][j - 1]] > f[st[i + power[j - 1]][j - 1]])
			{
				st[i][j] = st[i + power[j - 1]][j - 1];
			}
			else
			{
				st[i][j] = st[i][j - 1];
			}
		}
	}
}

int query(int x, int y)
{
	if(x > y)
	{
		swap(x, y);
	}
	int k = ln[y - x + 1];
	//for maximum, change ">" to "<"
	//for the last, change "<" or ">" to "<=" or ">="
	if (depth[st[x][k]] > depth[st[y - power[k] + 1][k]])
		return st[y - power[k] + 1][k];
	return st[x][k];
}
./RMQ&LCA/LCA_online_dfs.cpp
//first call init_LCA(root).
//then call LCA(a, b) to quest the LCA of a and b.
//the graph can be both bidirected or unidirected.
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define M 30

struct Edge
{
	int v, next, id;
	Edge()
	{}
	Edge(int v, int next, int id):v(v), next(next), id(id)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int id)
{
	edge[edge_cnt] = Edge(v, head[u], id);
	head[u] = edge_cnt++;
}

bool vis[MAX_NODE_NUM];
int father[MAX_NODE_NUM];
int power[M];
int st[MAX_NODE_NUM * 2][M];
int ln[MAX_NODE_NUM * 2];
int seq_cnt;
int seq[2*MAX_NODE_NUM];
int depth[2*MAX_NODE_NUM];
int first_appearance[MAX_NODE_NUM];

//returns the index of the first minimum value in [x, y]
void init_RMQ(int f[], int n)
{
	int i, j;
	for (power[0] = 1, i = 1; i < 21; i++)
	{
		power[i] = 2 * power[i - 1];
	}
	for (i = 0; i < n; i++)
	{
		st[i][0] = i;
	}
	ln[0] = -1;
	for (int i = 1; i <= n; i++)
	{
		ln[i] = ln[i >> 1] + 1;
	}
	for (j = 1; j < ln[n]; j++)
	{
		for (i = 0; i < n; i++)
		{
			if (i + power[j - 1] - 1 >= n)
			{
				break;
			}
			//for maximum, change ">" to "<"
			//for the last, change "<" or ">" to "<=" or ">="
			if (f[st[i][j - 1]] > f[st[i + power[j - 1]][j - 1]])
			{
				st[i][j] = st[i + power[j - 1]][j - 1];
			}
			else
			{
				st[i][j] = st[i][j - 1];
			}
		}
	}
}

int query(int x, int y)
{
	if(x > y)
	{
		swap(x, y);
	}
	int k = ln[y - x + 1];
	//for maximum, change ">" to "<"
	//for the last, change "<" or ">" to "<=" or ">="
	if (depth[st[x][k]] > depth[st[y - power[k] + 1][k]])
		return st[y - power[k] + 1][k];
	return st[x][k];
}


void dfs(int u ,int current_depth)
{
	vis[u] = true;
	first_appearance[u] = seq_cnt;
	depth[seq_cnt] = current_depth;
	seq[seq_cnt++] = u;
	for(int i = head[u]; i != -1; i = edge[i].next)
	{
		int v = edge[i].v;
		if (vis[v])
		{
			continue;
		}
		father[v] = u;
		if (!vis[v])
		{
			dfs(v, current_depth + 1);
			depth[seq_cnt] = current_depth;
			seq[seq_cnt++] = u;
		}
	}
}

void init_LCA(int root)
{
	memset(vis, 0, sizeof(vis));
	father[root] = -1;
	seq_cnt = 0;
	dfs(root, 0);
	init_RMQ(depth, seq_cnt);
}

//O(1)
int LCA(int u ,int v)
{
	int x = first_appearance[u];
	int y = first_appearance[v];
	int res = query(x, y);
	return seq[res];
}


./print.sh
./three_division.cpp
int three_division(int s, int e)
{
	int l = s;
	int r = e;
	while (l < r)
	{
		int len = r - l;
		int lmid = l + len / 3;
		int rmid = r - len / 3;
		if (cal(lmid) > cal(rmid))
		{
			r = rmid - 1;
		}else
		{
			l = lmid + 1;
		}
	}
	return cal(l);
}


./random.cpp
double random_double()
{
	return rand() * 1.0 / RAND_MAX;
}

int random_int(int bound)
{
	return (int) (random_double() * (bound - 1) + 0.5);
}

void init_random()
{
	srand(time(NULL));
}

./number theory
./number theory/prime_sieve.cpp
bool is_prime[MAX_N];
int prime[MAX_N];

int getprime(int n)
{
	int i, j, k = 0;
	int s, e = (int)(sqrt(0.0 + n) + 1);
	memset(is_prime, 1, sizeof(is_prime));
	prime[k++] = 2;
	is_prime[0] = is_prime[1] = 0;
	for (i = 4; i < n; i += 2) 
		is_prime[i] = 0;
	for (i = 3; i < e; i += 2)
		if (is_prime[i])
		{
			prime[k++] = i;
			for (s = i * 2, j = i * i; j < n; j += s)
				is_prime[j] = 0;
		}
	for ( ; i < n; i += 2)
		if (is_prime[i])
			prime[k++] = i;
	return k;
}
./number theory/gcd.cpp
LL gcd(LL a,LL b){
    if (a==0) return 1;
    if (a<0) return gcd(-a,b);
    while (b){
        LL t=a%b; a=b; b=t;
    }
    return a;
}
./number theory/pollard_rho.cpp
typedef long long LL;
#define maxn 10000
const int S = 20;

LL factor[maxn];
int tot;

LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

bool check(LL a, LL n, LL x, LL t)
{   //以a为基，n-1=x*2^t，检验n是不是合数
	LL ret = pow_mod(a, x, n), last = ret;
	for (int i = 1; i <= t; i++)
	{
		ret = multi_mod(ret, ret, n);
		if (ret == 1 && last != 1 && last != n - 1)
			return 1;
		last = ret;
	}
	if (ret != 1)
		return 1;
	return 0;
}

bool Miller_Rabin(LL n)
{
	LL x = n - 1, t = 0;
	while ((x & 1) == 0)
		x >>= 1, t++;
	bool flag = 1;
	if (t >= 1 && (x & 1) == 1)
	{
		for (int k = 0; k < S; k++)
		{
			LL a = rand() % (n - 1) + 1;
			if (check(a, n, x, t))
			{
				flag = 1;
				break;
			}
			flag = 0;
		}
	}
	if (!flag || n == 2)
		return 0;
	return 1;
}

LL gcd(LL a, LL b)
{
	if (a == 0)
		return 1;
	if (a < 0)
		return gcd(-a, b);
	while (b)
	{
		LL t = a % b;
		a = b;
		b = t;
	}
	return a;
}

LL Pollard_rho(LL x, LL c)
{
	LL i = 1, x0 = rand() % x, y = x0, k = 2;
	while (1)
	{
		i++;
		x0 = (multi_mod(x0, x0, x) + c) % x;
		LL d = gcd(y - x0, x);
		if (d != 1 && d != x)
		{
			return d;
		}
		if (y == x0)
			return x;
		if (i == k)
		{
			y = x0;
			k += k;
		}
	}
}

void findfac(LL n)
{           //递归进行质因数分解N
	if (!Miller_Rabin(n))
	{
		factor[tot++] = n;
		return;
	}
	LL p = n;
	while (p >= n)
		p = Pollard_rho(p, rand() % (n - 1) + 1);
	findfac(p);
	findfac(n / p);
}

./number theory/gcd_extend.cpp
void gcd_extend(long long a,long long b,long long &g,long long &x,long long &y)
{
	if (!b)
	{
		g = a;
		x = 1;
		y = 0;
		return;
	}
	gcd_extend(b, a % b, g, y, x);
	y -= a / b * x;
}
./number theory/Miller_Rabin.cpp
typedef long long LL;
#define maxn 10000
const int S = 20;

LL factor[maxn];
int tot;

LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

bool check(LL a, LL n, LL x, LL t)
{   //以a为基，n-1=x*2^t，检验n是不是合数
	LL ret = pow_mod(a, x, n), last = ret;
	for (int i = 1; i <= t; i++)
	{
		ret = multi_mod(ret, ret, n);
		if (ret == 1 && last != 1 && last != n - 1)
			return 1;
		last = ret;
	}
	if (ret != 1)
		return 1;
	return 0;
}

bool Miller_Rabin(LL n)
{
	LL x = n - 1, t = 0;
	while ((x & 1) == 0)
		x >>= 1, t++;
	bool flag = 1;
	if (t >= 1 && (x & 1) == 1)
	{
		for (int k = 0; k < S; k++)
		{
			LL a = rand() % (n - 1) + 1;
			if (check(a, n, x, t))
			{
				flag = 1;
				break;
			}
			flag = 0;
		}
	}
	if (!flag || n == 2)
		return 0;
	return 1;
}

./number theory/pow_mod.cpp
LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}

LL pow_mod(LL x, LL n, LL mod)
{  //返回x^n mod c ,非递归版
	x %= mod;
	if (n == 1)
		return x;
	LL ret = 1;
	while (n)
	{
		if (n & 1)
			ret = multi_mod(ret, x, mod);
		n >>= 1;
		x = multi_mod(x, x, mod);
	}
	return ret;
}

./number theory/multi_mod.cpp
LL multi_mod(LL a, LL b, LL c)
{    //返回(a*b) mod c,a,b,c<2^63
	a %= c;
	b %= c;
	LL ret = 0;
	while (b)
	{
		if (b & 1)
			ret = (ret + a) % c;
		a <<= 1;
		a %= c;
		b >>= 1;
	}
	return ret;
}


./network flow
./network flow/rng_58_dinic.cpp
#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef int F;
#define F_INF (1<<29)
#define MAXV 1000
#define MAXE 1000 // E*2!

F cap[MAXE],flow[MAXE];
int to[MAXE],_prev[MAXE],last[MAXV],used[MAXV],level[MAXV];

struct MaxFlow{
    int V,E;

    MaxFlow(int n){
        int i;
        V = n; E = 0;
        REP(i,V) last[i] = -1;
    }

    void add_edge(int x, int y, F f){
        cap[E] = f; flow[E] = 0; to[E] = y; _prev[E] = last[x]; last[x] = E; E++;
        cap[E] = 0; flow[E] = 0; to[E] = x; _prev[E] = last[y]; last[y] = E; E++;
    }

    bool bfs(int s, int t){
        int i;
        REP(i,V) level[i] = -1;
        queue <int> q;
        q.push(s); level[s] = 0;
        while(!q.empty()){
            int x = q.front(); q.pop();
            for(i=last[x];i>=0;i=_prev[i]) if(level[to[i]] == -1 && cap[i] > flow[i]) {q.push(to[i]); level[to[i]] = level[x] + 1;}
        }
        return (level[t] != -1);
    }

    F dfs(int v, int t, F f){
        int i;
        if(v == t) return f;
        for(i=used[v];i>=0;used[v]=i=_prev[i]) if(level[to[i]] > level[v] && cap[i] > flow[i]){
            F tmp = dfs(to[i],t,min(f,cap[i]-flow[i]));
            if(tmp > 0) {flow[i] += tmp; flow[i^1] -= tmp; return tmp;}
        }
        return 0;
    }

    F maxflow(int s, int t){
        int i;
        while(bfs(s,t)){
            REP(i,V) used[i] = last[i];
            while(dfs(s,t,F_INF) != 0);
        }
        F ans = 0;
        for(i=last[s];i>=0;i=_prev[i]) ans += flow[i];
        return ans;
    }

};
./network flow/min_cost_flow.cpp

#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define N MAX_NODE_NUM
#define E MAX_EDGE_NUM * 2
#define INF 0x3f3f3f3f

struct Edge
{
	int next, v, c, w;
	Edge()
	{}
	Edge(int next, int v, int c, int w): next(next), v(v), c(c), w(w)
	{}
}edge[E];

int node_num, edge_cnt;
bool vis[N];
int head[N], pre[N], pre_edge[N];
int dist[N];
int src, sink;
int q[MAX_NODE_NUM];
int front, rear, q_size;

void q_init(int size)
{
	front = 0;
	rear = 0;
	q_size = size;
}

void q_push(int a)
{
	q[rear++] = a;
	rear %= q_size;
}

int q_pop()
{
	int ret = q[front++];
	front %= q_size;
	return ret;
}

bool q_empty()
{
	return front == rear;
}


void add_edge(int u, int v, int c, int w)
{
	edge[edge_cnt] = Edge(head[u], v, c, w);
	head[u] = edge_cnt++;
}

void add_edges(int u, int v, int c, int w)
{
	add_edge(u, v, c, w);
	add_edge(v, u, 0, -w);
}

void SPFA()
{
	memset(vis, 0, sizeof(vis));
	fill(dist, dist + node_num, INF);
	dist[src] = 0;
	pre[src] = src;
	vis[src] = true;
	q_init(node_num);
	q_push(src);
	while (!q_empty())
	{
		int u = q_pop();
		vis[u] = false;
		for (int i = head[u]; ~i; i = edge[i].next)
		{
			int v = edge[i].v;
			if (!edge[i].c || edge[i].w + dist[u] >= dist[v])
				continue;
			dist[v] = edge[i].w + dist[u];
			if (!vis[v])
			{
				vis[v] = true;
				q_push(v);
			}
			pre[v] = u;
			pre_edge[v] = i;
		}
	}
}

int mincost(int src, int sink)
{
	int flow = 0;
	int cost = 0;
	while (true)
	{
		memset(pre, -1, sizeof(pre));
		SPFA();
		if (-1 == pre[sink])
			break;
		int max_flow = INF;
		for (int i = sink; i != src; i = pre[i])
			if (edge[pre_edge[i]].c < max_flow)
				max_flow = edge[pre_edge[i]].c;
		flow += max_flow;
		cost += dist[sink] * max_flow;
		for (int i = sink; i != src; i = pre[i])
		{
			edge[pre_edge[i]].c -= max_flow;
			edge[pre_edge[i] ^ 1].c += max_flow;
		}
	}
	return cost;
}

void init()
{
	edge_cnt = 0;
	memset(head, -1, sizeof(head));
}
./network flow/hugary_dfs_matrix.cpp
#define MAX_X 0
#define MAX_Y MAX_X

int matrix[MAX_X][MAX_Y];
bool vis[MAX_X];
int match[MAX_X];
int x_num, y_num;

bool find_match(int a)
{
	for (int i = 0; i < y_num; i++)
		if (matrix[a][i] &&!vis[i])
		{
			vis[i] = true;
			if (match[i] == -1|| find_match(match[i]))
			{
				match[i] = a;
				return true;
			}
		}
	return false;
}

int max_match()
{
	memset(match, -1, sizeof(match));
	for (int i = 0; i < x_num; i++)
	{
		memset(vis, 0, sizeof(vis));
		find_match(i);
	}
	int ans = 0;
	for (int i = 0; i < x_num; i++)
		if (match[i] != -1)
			ans++;
	return ans;
}

void init_match(int x, int y)
{
	x_num = x;
	y_num = y;
}
./network flow/dinic.cpp
#define MAX_NODE_NUM 0
#define MAX_EDGE_NUM 0
#define INF 0x3f3f3f3f

struct Edge
{
	int next, v, f;
	Edge()
	{}
	Edge(int next, int v, int f):next(next), v(v), f(f)
	{}
} edge[MAX_EDGE_NUM * 2];

int head[MAX_NODE_NUM];
int q[MAX_NODE_NUM];
bool vis[MAX_NODE_NUM];
int cur[MAX_NODE_NUM];
int dep[MAX_NODE_NUM];
int edge_cnt;
int path[MAX_NODE_NUM];
int front, rear, q_size;

void add_edge(int u, int v, int f)
{
	edge[edge_cnt] = Edge(head[u], v, f);
	head[u] = edge_cnt++;
	edge[edge_cnt] = Edge(head[v], u, 0);
	head[v] = edge_cnt++;
}

void init()
{
	edge_cnt = 0;
	memset(head, -1, sizeof(head));
}

void q_init(int size)
{
	front = 0;
	rear = 0;
	q_size = size;
}

void q_push(int a)
{
	q[rear++] = a;
	rear %= q_size;
}

int q_pop()
{
	int ret = q[front++];
	front %= q_size;
	return ret;
}

void bfs(int s, int t)
{
	memset(vis, 0, sizeof(vis));
	memset(dep, -1, sizeof(dep));
	q_init(MAX_NODE_NUM);
	q_push(s);
	vis[s] = true;
	dep[s] = 0;
	while (front != rear && !vis[t])
	{
		int u = q_pop();
		for (int i = head[u]; ~i; i = edge[i].next)
		{
			int v = edge[i].v;
			if (!vis[v] && edge[i].f > 0)
			{
				q_push(v);
				vis[v] = true;
				dep[v] = dep[u] + 1;
			}
		}
	}
}

int add_flow(int path[], int &path_n)
{
	int min_edge = -1, delta = INF;
	for (int i = 0; i < path_n; ++i)
	{
		if (edge[path[i]].f < delta)
		{
			delta = edge[path[i]].f;
			min_edge = i;
		}
	}
	for (int i = 0; i < path_n; ++i)
	{
		edge[path[i]].f -= delta;
		edge[path[i] ^ 1].f += delta;
	}
	path_n = min_edge;
	return delta;
}

int last_node(int path[], int path_n, int s)
{
	if (path_n)
		return edge[path[path_n - 1]].v;
	return s;
}

int find_next(int start)
{
	for (int e = cur[start]; ~e; e = edge[e].next)
		if (edge[e].f && dep[start] + 1 == dep[edge[e].v])
			return e;
	return -1;
}

int dfs(int s, int t)
{
	int ret = 0;
	int path_n = 0;
	int x = s;
	memcpy(cur, head, sizeof(cur));
	while (true)
	{
		if (x == t)
		{
			ret += add_flow(path, path_n);
			x = last_node(path, path_n, s);
		}
		int next_edge = find_next(x);
		cur[x] = next_edge;
		if (next_edge == -1)
		{
			if (path_n == 0)
				break;
			dep[x] = -1;
			--path_n;
			x = last_node(path, path_n, s);
			continue;
		}
		path[path_n++] = next_edge;
		x = edge[next_edge].v;
	}
	return ret;
}

int dinic(int s, int t)
{
	int ret = 0;
	while (true)
	{
		bfs(s, t);
		if (dep[t] == -1)
			return ret;
		ret += dfs(s, t);
	}
	return -1;
}


./network flow/hugary_dfs_list.cpp
#define MAX_X 0
#define MAX_Y MAX_X
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM MAX_X

struct Edge
{
	int v, next;
	Edge()
	{}
	Edge(int v, int next):v(v), next(next)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
bool vis[MAX_X];
int match[MAX_X];
int x_num, y_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v)
{
	edge[edge_cnt].v = Edge(v, head[u]);
	head[u] = edge_cnt++;
}

bool find_match(int a)
{
	for (int i = head[a]; ~i; i = edge[i].next)
	{
		int v = edge[i].v;
		if (vis[v])
			continue;
		vis[v] = true;
		if (match[v] == -1 || find_match(match[v]))
		{
			match[v] = a;
			return true;
		}
	}
	return false;
}

int max_match()
{
	memset(match, -1, sizeof(match));
	for (int i = 0; i < x_num; i++)
	{
		memset(vis, 0, sizeof(vis));
		find_match(i);
	}
	int ans = 0;
	for (int i = 0; i < x_num; i++)
		if (match[i] != -1)
			ans++;
	return ans;
}

void init_match(int x, int y)
{
	x_num = x;
	y_num = y;
}

./dynamic programming
./dynamic programming/digits_leading_zeros.cpp
const int MAX_DIGIT = 20;

long long n;
int f[MAX_DIGIT];
long long memoize[MAX_DIGIT][...];

int to_digits(long long a)
{
	int ret = 0;
	while (a > 0)
	{
		f[ret++] = a % 10;
		a /= 10;
	}
	return ret;
}

long long dfs(int digit, bool less, bool leading_zero, ...)
{
	if (digit < 0)
	{
		return ...;
	}
	if (less && !leading_zero && memoize[digit][...] != -1)
	{
		return memoize[digit][...];
	}
	int limit = less ? 9 : f[digit];
	long long ret = 0;
	for (int i = 0; i <= limit; i++)
	{
		ret += dfs(digit - 1, less || i < f[digit], leading_zero && i == 0, ...);
	}
	if (less && !leading_zero)
	{
		memoize[digit][...] = ret;
	}
	return ret;
}

long long work(long long n)
{
	if (n < 0)
	{
		return 0;
	}
	if (n == 0)
	{
		//return 1;
	}
	int len = to_digits(n);
	memset(memoize, -1, sizeof(memoize));
	return dfs(len - 1, false, 0, ...);
}
./dynamic programming/digits.cpp
const int MAX_DIGIT = 20;

long long n;
int f[MAX_DIGIT];
long long memoize[MAX_DIGIT][...];

int to_digits(long long a)
{
	int ret = 0;
	while (a > 0)
	{
		f[ret++] = a % 10;
		a /= 10;
	}
	return ret;
}

long long dfs(int digit, bool less, ...)
{
	if (digit < 0)
	{
		return ...;
	}
	if (less && memoize[digit][...] != -1)
	{
		return memoize[digit][...];
	}
	int limit = less ? 9 : f[digit];
	long long ret = 0;
	for (int i = 0; i <= limit; i++)
	{
		ret += dfs(digit - 1, less || i < f[digit], ...);
	}
	if (less)
	{
		memoize[digit][...] = ret;
	}
	return ret;
}

long long work(long long n)
{
	if (n < 0)
	{
		return 0;
	}
	if (n == 0)
	{
		//return 1;
	}
	int len = to_digits(n);
	memset(memoize, -1, sizeof(memoize));
	return dfs(len - 1, false, ...);
}
./data structures
./data structures/queue.cpp
template<typename T>
class queue
{
	T data[MAX_Q_LEN];
	int head, tail;

public:
	queue()
	{
		head = tail = 0;
	}

	bool empty()
	{
		return head == tail;
	}

	void pop()
	{
		head++;
		if (head >= MAX_Q_LEN)
			head = 0;
	}

	void push(T a)
	{
		data[tail++] = a;
		if (tail >= MAX_Q_LEN)
			tail = 0;
	}

	T front()
	{
		return data[head];
	}
};

./data structures/tree_dfn.cpp
int dfn[MAX_N], dfn2[MAX_N];
int time_count;

void dfs(int u, int father)
{
	dfn[u] = time_count++;
	for (int i = 0; i < (signed)edge[u].size(); i++)
	{
		int v = edge[u][i];
		if (v != father)
			dfs(v, u);
	}
	dfn2[u] = time_count;	//can be deleted, if dfn2 is not necessary.
}

./data structures/dsu.cpp

struct DSU
{
	int father[MAX_NODE_NUM];

	DSU()
	{}

	DSU(int n)
	{
		for (int i = 0; i < n; i++)
		{
			father[i] = i;
		}
	}

	int find(int a)
	{
		int ret = a;
		while (father[ret] != ret)
			ret = father[ret];
		while (father[a] != a)
		{
			int b = a;
			a = father[a];
			father[b] = ret;
		}
		return ret;
	}

	void merge(int a, int b)
	{
		father[find(a)] = father[find(b)];
	}
};


./data structures/binary_indexed_tree.cpp
int binary_indexed_tree[MAX_N];

int low_bit(int x)
{
	return x & (-x);
}

void add(int pos, int val)
{
	for (int i = pos; i < MAX_N; i += low_bit(i))
	{
		binary_indexed_tree[i] += val;
	}
}

int sum(int pos)
{
	int ret = 0;
	for (int i = pos; i > 0; i -= low_bit(i))
	{
		ret += binary_indexed_tree[i];
	}
	return ret;
}


./data structures/trie.cpp
const int MAX_CHAR_NUM = 0;
const int MAX_NODE_NUM = 0;

int trie[MAX_NODE_NUM][MAX_CHAR_NUM];
int node_num;

void trie_init()
{
	memset(trie, -1, sizeof(trie));
	node_num = 1;
}

int convert(char ch)
{
	return ch - 'a';
}

void add(char* st)
{
	int u = 0;
	for (int i = 0; st[i]; i++)
	{
		int index = convert(st[i]);
		if (trie[u][index] == -1)
		{
			trie[u][index] = node_num++;
		}
		u = trie[u][index];
	}
}
./IO_accelerator
./IO_accelerator/read_int.cpp
inline int read_int()
{
    int num = 0;
    int sign = 1;
    bool skip = false;
    int c = 0;
    while((c = getchar()) != EOF)
    {
        if(c == '-')
        {
            sign = -1;
            skip = true;
        }
        else if(c >= '0' && c <= '9')
        {
            num = num * 10 + c - '0';
            skip = true;
        }
        else if(skip)
	{
		break;
	}
    }
    return num * sign;
}

./segment tree
./segment tree/segment_tree(general).cpp
struct SegmentTree
{

    struct Node
    {
        int l, r;
        Node *pleft, *pright;
        //add the needed variable
    }tree[MAX_INTERVAL *4];

    int node_cnt;

    void init()
    {
        node_cnt = 0;
    }

    Node* new_node()
    {
        node_cnt++;
        return tree + node_cnt;
    }

    void build_tree(Node *proot, int s, int e)
    {
        proot->l = s;
        proot->r = e;
        //init the variables
        if (s == e)
        {
            proot->pleft = proot->pright = NULL;
            return;
        }
        int mid = (s + e) / 2;
        build_tree(proot->pleft = new_node(), s, mid);
        build_tree(proot->pright = new_node(), mid + 1, e);
    }

    void pull_up(Node *proot)
    {
            //do something
    }

    void push_down(Node *proot)
    {
            //do something
    }

    void update(Node *proot, int start, int end, int value)
    {
        if (start > proot->r || end < proot->l)
            return;
        start = max(start, proot->l);
        end = min(end, proot->r);
        if (start == proot->l && end == proot->r)
        {
            //do something
            return;
        }
        push_down(proot);
        update(proot->pleft, start, end, value);
        update(proot->pright, start, end, value);
        pull_up(proot);
    }

    int query(Node *proot, int start, int end)
    {
        int ret = proot->value;
        if (start > proot->r || end < proot->l)
            return 0;
        start = max(start, proot->l);
        end = min(end, proot->r);
        if (start == proot->l && end == proot->r)
        {
            //do something
        }
        push_down(proot);
        ret = max(ret, query(proot->pleft, start, end));
        ret = max(ret, query(proot->pright, start, end));
        pull_up(proot);
        return ret;
    }
};
./segment tree/segment_tree(cover).cpp

struct SegmentTree
{

	struct Node
	{
		int l, r;
		long long h;
		Node *pleft, *pright;
		long long value;
	}tree[MAX_INTERVAL *4];

	int discrete[MAX_INTERVAL *2], node_cnt, discrete_num;

	void init()
	{
		node_cnt = 0;
	}

	void build_tree(Node *proot, int s, int e)
	{
		proot->l = s;
		proot->r = e;
		proot->h = 0;
		proot->value = 0;
		if (s == e)
		{
			proot->pleft = proot->pright = NULL;
			return;
		}
		node_cnt++;
		proot->pleft = tree + node_cnt;
		node_cnt++;
		proot->pright = tree + node_cnt;
		int mid = (s + e) / 2;
		build_tree(proot->pleft, s, mid);
		build_tree(proot->pright, mid + 1, e);
	}

	void pull_up(Node *proot)
	{
		proot->value = proot->pleft->value + proot->pright->value;
	}

	void push_down(Node *proot)
	{
		if (proot->h != -1 && proot->r != proot->l)
		{
			update(proot->pleft, proot->pleft->l, proot->pleft->r, proot->h);
			update(proot->pright, proot->pright->l, proot->pright->r, proot->h);
			proot->h = -1;
		}
	}

	void update(Node *proot, int start, int end, long long h)
	{
		if (start > proot->r || end < proot->l)
			return;
		start = max(start, proot->l);
		end = min(end, proot->r);
		if (start == proot->l && end == proot->r)
		{
			proot->h = h;
			proot->value = h * (discrete[proot->r + 1] - discrete[proot->l]);
			return;
		}
		push_down(proot);
		update(proot->pleft, start, end, h);
		update(proot->pright, start, end, h);
		pull_up(proot);
	}
};


./segment tree/segment_tree(discrete).cpp
#define MAX_LEN 0

struct Node
{
	Node *pleft;
	Node *pright;
	long long l, r;
	long long sum;
} tree[MAX_LEN * 3];

int len;
long long sum;
int ncount;

void build_tree(Node *proot, int l, int r)
{
	int mid = (l + r) / 2;
	proot->l = l;
	proot->r = r;
	proot->sum = 0;
	if (l == r)
		return;
	ncount++;
	proot->pleft = tree + ncount;
	ncount++;
	proot->pright = tree + ncount;
	build_tree(proot->pleft, l, mid);
	build_tree(proot->pright, mid + 1, r);
}

long long query(Node *proot, long long l, long long r)
{
	if (l > proot->r || r < proot->l)
	{
		return 0;
	}
	l = max(proot->l, l);
	r = min(proot->r, r);
	if (l == proot->l && r == proot->r)
	{
		D(puts("***"));
		return proot->sum;
	}
	return (query(proot->pleft, l, r) + query(proot->pright, l, r)) % MOD;
}

void update(Node *proot, long long pos, long long a)
{
	if (pos > proot->r || pos < proot->l)
	{
		return;
	}
	proot->sum += a;
	proot->sum %= MOD;
	if (proot->l == proot->r)
	{
		return;
	}
	update(proot->pleft, pos, a);
	update(proot->pright, pos, a);
}

./segment tree/segment_tree(reserve).cpp
#define MAX_INTERVAL 100001

struct Node
{
	int        l, r;
	long long nsum, inc;
	Node    *pleft, *pright;
};

int	node_cnt;
Node    tree[MAX_INTERVAL * 3];

void buildtree(Node *proot, int s, int e)
{
	proot->l = s;
	proot->r = e;
	proot->inc = 0;
	proot->nsum = 0;
	if (s == e)
	{
		proot->pleft = proot->pright = NULL;
		return;
	}
	node_cnt++;
	proot->pleft = tree + node_cnt;
	node_cnt++;
	proot->pright = tree + node_cnt;
	buildtree(proot->pleft, s, (s + e) / 2);
	buildtree(proot->pright, (s + e) / 2 + 1, e);
}

void insert(Node *proot, int s, int e, long long increase)
{
	if (s > proot->r || e < proot->l)
		return;
	s = max(s, proot->l);
	e = min(e, proot->r);
	if (s == proot->l && e == proot->r)
	{
		proot->inc += increase;
		return;
	}
	proot->nsum += (e - s + 1) * increase;
	insert(proot->pleft, s, e, increase);
	insert(proot->pright, s, e, increase);
}

long long query(Node *proot, int s, int e)
{
	if (s > proot->r || e < proot->l)
		return 0;
	s = max(s, proot->l);
	e = min(e, proot->r);
	if (proot->l == s && proot->r == e)
		return proot->nsum + proot->inc * (proot->r - proot->l + 1);
	long long inc_value = proot->inc * (e - s + 1);
	return query(proot->pleft, s, e) + query(proot->pright, s, e) + inc_value;
}


./README.md
./graph theory
./graph theory/dijkstra_matrix.cpp
int vis[maxn];
int cost[maxn][maxn];
int lowcost[maxn];
int n;

void dijkstra(int beg)
{
	int i, j, min;
	memset(vis, 0, sizeof(vis));
	vis[beg] = 1;
	for (i = 0; i < n; i++)
		lowcost[i] = cost[beg][i];
	lowcost[beg] = 0;
	int pre = beg;
	for (i = 1; i < n; i++)
	{
		min = inf;
		for (j = 0; j < n; j++)
			if (vis[j] == 0 && lowcost[pre] + cost[pre][j] < lowcost[j])
				lowcost[j] = lowcost[pre] + cost[pre][j];
		for (j = 0; j < n; j++)
			if (vis[j] == 0 && lowcost[j] < min)
			{
				min = lowcost[j];
				pre = j;
			}
		vis[pre] = 1;
	}
}
./graph theory/floyd.cpp
int dist[MAX_NODE_NUM][MAX_NODE_NUM];
int node_num;

void init()
{
	memset(dist, -1, sizeof(dist));
}

void floyd()
{
	for (int i = 0; i < node_num; i++)
	{
		for (int j = 0; j < node_num; j++)
		{
			if (dist[j][i] == -1)
				continue;
			for (int k = 0; k < node_num; k++)
			{
				if (dist[i][k] == -1)
					continue;
				if (dist[j][k] == -1 || dist[j][k] > dist[j][i] + dist[i][k])
					dist[j][k] = dist[j][i] + dist[i][k];
			}
		}
	}
}
./graph theory/dfn.cpp
void dfs(int u, int parent)
{
    dfn[u][0] = ++dfn_cnt;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if (v != parent)
        {
            dfs(v, u);
        }
    }
    dfn[u][1] = dfn_cnt;
}
./graph theory/SPFA(vector).cpp
#define MAX_NODE_NUM 105
#define INF 0x3f3f3f3f

int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];
int push_cnt[MAX_NODE_NUM];
bool in_queue[MAX_NODE_NUM];

bool relax(int &dist, int length)
{
	if (dist > length)
	{
		dist = length;
		return true;
	}
	return false;
}

int SPFA(int origin, int destination)
{
	fill(dist, dist + node_num, INF);
	fill(push_cnt, push_cnt + node_num, 0);
	fill(in_queue, in_queue + node_num, 0);
	queue<int> q;
	q.push(origin);
	in_queue[origin] = true;
	dist[origin] = 0;
	bool unbound = false;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		in_queue[u] = false;
		for (int i = 0; i < edge[u].size(); i++)
		{
			int v = edge[u][i].first;
			int w = edge[u][i].second;
			if (relax(dist[v], dist[u] + w) && !in_queue[v]) 
			{
				q.push(i->v);
				in_queue[i->v] = true;
				push_cnt[i->v]++;
				if (push_cnt[i->v] > node_num)
				{
					return -1;		//negative ring;
				}
			}
		}
	}
	return dist[destination];
}

./graph theory/dijkstra_Edge.cpp
struct Edge
{
	int v, next;
	long long w;
	Edge()
	{}
	Edge(int v, int next, long long w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}


bool vis[MAX_NODE_NUM];
long long dist[MAX_NODE_NUM];

void dijkstra(int source)
{
	memset(vis, 0, sizeof(vis));
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	while (true)
	{
		int min_dist = INF;
		int min_node = -1;

		for (int i = 0; i < node_num; i++)
		{
			if (!vis[i] && dist[i] < min_dist)
			{
				min_dist = dist[i];
				min_node = i;
			}
		}
		if (min_node == -1)
		{
			break;
		}
		vis[min_node] = true;
		for (int i = head[min_node]; i!= -1; i = edge[i].next)
		{
			int v = edge[i].v;
			int w = edge[i].w;
			dist[v] = min(dist[min_node] + w, dist[v]);
		}
	}
}
./graph theory/graph(vector).cpp
int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];

	edge[u].push_back(make_pair(v, w));
./graph theory/topological_order.cpp
vector<int> edge[MAX_N];
int degree[MAX_N];

void add_edge(int a, int b)
{
	edge[a].push_back(b);
	degree[b]++;
}

void bfs(int node_num, vector<int> edge[])
{
	//indexes start from 0
	queue<int> q;
	for (int i = 0; i < node_num; i++)
	{
		if (degree[i] == 0)
		{
			q.push(i);
		}
	}
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		//push u into an array to get the topological order sequence
		for (int i = 0; i < (int)edge[u].size(); i++)
		{
			int v = edge[u][i];
			if (degree[v] == 0)
			{
				continue;
			}
			degree[v]--;
			if (degree[v] == 0)
			{
				q.push(v);
			}
		}
	}
	//if degree[i] != 0 now, it means there is a circle on the connected component with vertex i.
}

./graph theory/dijkstra_Edge_pq.cpp
struct Edge
{
	int v, next;
	long long w;
	Edge()
	{}
	Edge(int v, int next, long long w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, int w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}


long long dist[MAX_NODE_NUM];
priority_queue<Edge> pq;

void dijkstra(int source)
{
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	pq.push(Edge(0, -1, 0));
	while (!pq.empty())
	{
		Edge a;
		a = pq.top();
		pq.pop();
		if (dist[a.v] != a.w)
			continue;
		for (int i = head[a.v]; i!= -1; i = edge[i].next)
		{
			int v = edge[i].v;
			long long w = edge[i].w + a.w;
			if (dist[v] > w)
			{
				dist[v] = w;
				pq.push(Edge(v, -1, dist[v]));
			}
		}
	}
}


./graph theory/prim.cpp

#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0
#define INF 0x3f3f3f3f

struct Edge
{
	int v, next;
	double w;
	Edge()
	{}
	Edge(int v, int next, double w):v(v), next(next), w(w)
	{}
} edge[MAX_EDGE_NUM];

int head[MAX_NODE_NUM];
int edge_cnt;
int node_num, edge_num;
double dist[MAX_NODE_NUM];
bool vis[MAX_NODE_NUM];

void init_edge()
{
	memset(head, -1, sizeof(head));
	edge_cnt = 0;
}

void add_edge(int u, int v, double w)
{
	edge[edge_cnt] = Edge(v, head[u], w);
	head[u] = edge_cnt++;
}

void input()
{
	init_edge();
	for (int i = 0; i < node_num; i++)
	{
		int a, b;
		double w;
		scanf("%d%d%lf", &a, &b, &w);
		add_edge(a, b, w);
		add_edge(b, a, w);
	}
}

int find_best()
{
	int ret = -1;
	double max_dist = INF;
	for (int i = 0; i < node_num; i++)
	{
		if (!vis[i] && dist[i] < max_dist)
		{
			ret = i;
			max_dist = dist[i];
		}
	}
	return ret;
}

void alter_neighbours(int u)
{
	for (int i = head[u]; ~i; i = edge[i].next)
	{
		int v = edge[i].v;
		double w = edge[i].w;
		dist[v] = min(dist[v], w);
	}
}

double prim(int s)
{
	double ret = 0;
	fill(dist, dist + node_num, INF);
	memset(vis, 0, sizeof(vis));
	dist[0] = 0;
	int cnt = 0;
	while (true)
	{
		int u = find_best();
		if (u == -1)
			break;
		vis[u] = true;
		cnt++;
		ret += dist[u];
		alter_neighbours(u);
	}
	if (cnt < node_num)
		return -1;//if the graph is not connected
	return ret;
}
./graph theory/dijkstra_vector_pq.cpp
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0
#define INF (1LL << 60)

int node_num, edge_num;
long long dist[MAX_NODE_NUM];
vector<pair<int, int> > edge[MAX_NODE_NUM];

void input()
{
	scanf("%d%d", &node_num, &edge_num);
	for (int i = 0; i < edge_num; i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		v--;
		u--;
		edge[u].push_back(make_pair(v, w));
		edge[v].push_back(make_pair(u, w));
	}
}

priority_queue<pair<long long, int> > pq;

void dijkstra(int source)
{
	fill(dist, dist + node_num, INF);
	dist[source] = 0;
	pq.push(make_pair(0LL, 0));
	for (int i = 0; i < node_num; i++)
		if (train[i])
		{
			pq.push(make_pair(-dist[i], i));
		}
	while (!pq.empty())
	{
		int u = pq.top().second;
		long long w = -pq.top().first;
		pq.pop();
		if (dist[u] != w)
			continue;
		for (int i = 0; i < (int)edge[u].size(); i++)
		{
			int v = edge[u][i].first;
			long long new_w = edge[u][i].second + w;
			if (dist[v] >= new_w && train[v])
			{
				train[v] = false;
			}
			if (dist[v] > new_w)
			{
				dist[v] = new_w;
				pq.push(make_pair(-dist[v], v));
			}
		}
	}
}

./graph theory/struct Edge.cpp
#define MAX_EDGE_NUM 0
#define MAX_NODE_NUM 0

struct Edge
{
	int v, next;
	Edge()
	{}
	Edge(int v, int next):v(v), next(next)
	{}
};

struct Graph
{
	int head[MAX_NODE_NUM];
	int edge_cnt;
	Edge edge[MAX_EDGE_NUM];

	void init()
	{
		memset(head, -1, sizeof(head));
		edge_cnt = 0;
	}

	void add(int u, int v)
	{
		edge[edge_cnt] = Edge(v, head[u]);
		head[u] = edge_cnt++;
	}

	int next(int a)
	{
		return edge[a].next;
	}

	int v(int a)
	{
		return edge[a].v;
	}
};
./3d geometry.cpp
#define zero(x) (((x)>0?(x):-(x))<eps)
#define eps 1.0E-8
#define MAX_POINT_NUM 0

int double_cmp(double a)
{
	if (zero(a))
		return 0;
	return a > 0 ? 1 : -1;
}

struct Point
{
	double x, y, z;

	Point()
	{}

	Point(double x, double y, double z): x(x), y(y), z(z)
	{}

	Point operator - (const Point &a) const
	{
		return Point(x - a.x, y - a.y, z - a.z);
	}

	Point operator + (const Point &a) const
	{
		return Point(x + a.x, y + a.y, z + a.z);
	}

	bool operator == (const Point &a) const
	{
		return !double_cmp(x - a.x) && !double_cmp(y - a.y) && !double_cmp(z - a.z);
	}
};

double dot_product(Point a, Point b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

double point_dist(Point a)
{
	return a.x * a.x + a.y * a.y + a.z * a.z;
}
./combinatorial math
./combinatorial math/bit_enumerate.cpp
	for (int i = 1; i < (1 << bit_num); i++)
	{
		//i is the 01-bits sequence
		for (int j = 0; (i >> j) > 0; j++)
		{
			if ((i >> j) & 1)
			{
				//the j-th bit is 1
			}
		}
	}

./computational geometry.cpp
#define zero(x) (((x)>0?(x):-(x))<eps)
#define eps 1.0E-8
#define MAX_POINT_NUM 0

int double_cmp(double a)
{
	if (zero(a))
		return 0;
	return a > 0 ? 1 : -1;
}

struct Point
{
	double	x,y;
	Point()
	{}
	Point(double x, double y):x(x), y(y)
	{}
	Point operator - (Point &a)
	{
		return Point(x - a.x, y - a.y);
	}	
	bool operator <(const Point &a)const
	{
	    return atan2(y, x) < atan2(a.y, a.x);
	}
	bool operator == (const Point &a) const
	{
		return x == a.x && y == a.y;
	}
};

double cross_product(Point a, Point b)
{
	return a.x * b.y - b.x * a.y;
}

double cross_product(Point p0, Point p1, Point p2)
{
	return cross_product(p1 - p0, p2 - p0);
}

double dot_product(Point a, Point b)
{
	return a.x * b.x + a.y * b.y;
}

double dot_product(Point p0, Point p1, Point p2)
{
	return dot_product(p1 - p0, p2 - p0);
}

double point_dist(Point a)
{
	return sqrt(a.x * a.x + a.y * a.y);
}

double point_dist(Point a, Point b)
{
	return point_dist(a - b);
}

struct Line
{
	Point a, b;
	Line()
	{}
	Line(Point a, Point b):a(a), b(b)
	{}	
	bool operator == (const Line &l) const
	{
		return l.a == a && l.b == b;
	}
};

bool points_inline(Point p1, Point p2, Point p3)
{
	return zero(cross_product(p1, p2, p3));
}

bool same_side(Point p1, Point p2, Line l)
{
	return double_cmp(cross_product(l.a, p1, l.b) * cross_product(l.a, p2, l.b)) > 0;
}

bool point_online_inclusive(Point p, Line l)
{
	return double_cmp(zero(cross_product(p, l.a, l.b)) && dot_product(p, l.a, l.b)) <= 0;
}

bool point_online_exclusive(Point p, Line l)
{
	return zero(cross_product(p, l.a, l.b)) && double_cmp(dot_product(p, l.a, l.b)) < 0;
}

bool overlap_exclusive(Line u, Line v)
{
	if (u == v || (u.a == v.b && u.b == v.a))
		return true;
	if (!points_inline(u.a, u.b, v.a) || !points_inline(u.a, u.b, v.b))
		return false;
	bool ret = point_online_exclusive(u.a, v);
	ret = ret || point_online_exclusive(u.b, v);
	ret = ret || point_online_exclusive(v.a, u);
	ret = ret || point_online_exclusive(v.b, u);
	return ret;
}

bool intersect_inclusive(Line u, Line v)
{
	if (!points_inline(u.a, u.b, v.a) || !points_inline(u.a, u.b, v.b))
		return !same_side(u.a, u.b, v) && !same_side(v.a, v.b, u);
	bool ret = point_online_inclusive(u.a, v);
	ret = ret || point_online_inclusive(u.b, v);
	ret = ret || point_online_inclusive(v.a, u);
	ret = ret || point_online_inclusive(v.b, u);
	return ret;
}

double line_length(Line l)
{
	return point_dist(l.a - l.b);
}

double point_line_dist(Point a, Line l)
{
	return abs(cross_product(l.a - a, l.b - a) / line_length(l));
}

Point intersection_point(Line l1,Line l2)
{
    double s1 = cross_product(l1.a, l1.b, l2.a);
    double s2 = cross_product(l1.a, l1.b, l2.b);
    Point ret;
    ret.x = (s1 * l2.b.x - s2 * l2.a.x) / (s1 - s2);
    ret.y = (s1 * l2.b.y - s2 * l2.a.y) / (s1 - s2);
    return ret;
}

struct Polygon
{
	Point point[MAX_POINT_NUM];
	int point_num;
};

bool convex(Polygon &a) //point should be counter-clockwise
{
	for (int i = 0; i < a.point_num; i++)
	{
		Point p1 = a.point[(i + 1) % a.point_num] - a.point[i];
		Point p2 = a.point[(i + 2) % a.point_num] - a.point[(i + 1) % a.point_num];
		if (double_cmp(cross_product(p1, p2)) < 0)
			return false;
	}
	return true;
}

bool point_in_convex(Polygon &a, Point peg) //point should be counter-clockwise
{
	for (int i = 0; i < a.point_num; i++)
	{
		Point p1 = a.point[(i + 1) % a.point_num] - a.point[i];
		Point p2 = peg - a.point[(i + 1) % a.point_num];
		if (double_cmp(cross_product(p1, p2)) <= 0)
			return false;
	}
	return true;
}
./binary_search.cpp
int binary_search(int start, int end, int a)
{
	int l = start;
	int r = end;
	while (l < r)
	{
		int mid = (l + r) / 2;
		if (ok(mid, a))
			r = mid;
		else
			l = mid + 1;
	}
	return l;
}


./matrix_multiply_pow.cpp
#define MAX_MATRIX_SIZE 101
#define MOD 100000

struct Matrix
{
	int order;
	int num[MAX_MATRIX_SIZE][MAX_MATRIX_SIZE];

	Matrix()
	{}

	Matrix(int ord)
	{
		order = ord;
	}

	void init()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				num[i][j] = 0;
			}
		}
	}
	void output()
	{
		for (int i = 0; i < order; i++)
		{
			for (int j = 0; j < order; j++)
			{
				printf("%d ", num[i][j]);
			}
			puts("");
		}
	}
};

Matrix operator*(Matrix ma, Matrix mb)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	int i, j, k;
	for (i = 0; i < ord; i++)
	{
		for (k = 0; k < ord; k++)
		{
			if (ma.num[i][k] == 0)
				continue;
			for (j = 0; j < ord; j++)
			{
				long long temp = ma.num[i][k] * (long long)mb.num[k][j];
				temp %= MOD;
				numc.num[i][j] += temp;
				numc.num[i][j] %= MOD;
			}
		}
	}
	return numc;
}

Matrix matrix_power(Matrix ma, int x)
{
	int ord = ma.order;
	Matrix numc(ord);
	numc.init();
	for (int i = 0; i < ord; i++)
	{
		numc.num[i][i] = 1;
	}
	for (; x; x >>= 1)
	{
		if (x & 1)
		{
			numc = numc * ma;
		}
		ma = ma * ma;
	}
	return numc;
}
